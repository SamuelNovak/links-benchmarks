# Library

typename Ord = [| Lower | Greater | Equal |];
typename Order(a, e::Eff) = (a, a) ~e~> Ord;

typename Tree(a, b) = mu t. [| Node:(left:t, key:a, value:b, right:t) | Leaf |];
typename Map(a, b, e::Eff) = (ord:Order(a, { |e}), tree:Tree(a,b));

sig def_ord : Order(a, { |e})
fun def_ord(x, y) { if (x == y) Equal else if (x < y) Lower else Greater }

sig make_map : (Order(a, { |e})) -f-> Map(a, b, { |e})
fun make_map(ord) {
  (ord=ord, tree=Leaf)
}

sig find_tree_opt : (Order (a,{ |e}), a, Tree (a,b)) ~e~> Maybe (b)
fun find_tree_opt(ord, key, tree) {
  switch (tree) {
    case Leaf -> Nothing
    case Node(tree) ->
      switch (ord(key, tree.key)) {
        case Equal   -> Just(tree.value)
        case Lower   -> find_tree_opt(ord, key, tree.left)
        case Greater -> find_tree_opt(ord, key, tree.right)
      }
  }
}

sig ref_map : (a, Map(a,b,{ |e})) ~e~> Maybe(b)
fun ref_map(key, mp) {
  var (ord=ord, tree=tree) = mp;
  find_tree_opt(ord, key, tree)
}

# TODO rebalancing
sig upd_tree : (Order(a, { |e}), a, b, Tree(a,b)) ~> Tree(a,b)
fun upd_tree(ord, key, value, tree) {
  var tree = switch (tree) {
               case Leaf -> (key=key, value=value, left=Leaf, right=Leaf)
               case Node(tree) ->
                 switch (ord(key, tree.key)) {
                   case Equal   -> (tree with value = value)
                   case Lower   -> (tree with left  = upd_tree(ord, key, value, tree.left))
                   case Greater -> (tree with right = upd_tree(ord, key, value, tree.right))
                 }
             };
  Node(tree)
}

sig upd_map : (a, b, Map(a,b,{ |e})) ~e~> Map(a,b,{ |e})
fun upd_map(key, value, mp) {
  var (ord=ord, tree=tree) = mp;
  (mp with tree = upd_tree(ord, key, value, tree))
}

sig map_tree : ((a) ~> b, Tree(k, a)) ~> Tree(k, b)
fun map_tree(f, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(tree) ->
      var left  = map_tree(f, tree.left);
      var value = f(tree.value);
      var right = map_tree(f, tree.right);
      Node(key=tree.key, value=value, left=left, right=right)
  }
}

sig map_map : ((a) ~f~> b, Map(k, a, { |e})) ~f~> Map(k, b, { |e})
fun map_map(f, mp) {
  var (ord=ord, tree=tree) = mp;
  var tree = map_tree(f, tree);
  (ord=ord, tree=tree)
}

sig fold_tree : ((a, b, q) ~e~> q, Tree(a, b), q) ~e~> q
fun fold_tree(f, tree, acc) {
  switch (tree) {
    case Leaf -> acc
    case Node(tree) ->
      var acc = fold_tree(f, tree.left, acc);
      var acc = f(tree.key, tree.value, acc);
      var acc = fold_tree(f, tree.right, acc);
      acc
  }
}

sig fold_map : ((a, b, q) ~e~> q, Map(a, b, { |e}), q) ~e~> q
fun fold_map(f, mp, acc) {
  var (ord=ord, tree=tree) = mp;
  fold_tree(f, tree, acc)
}

sig merge_subtrees : (Order(a, { |e}), Tree(a,b), Tree(a,b)) ~e~> Tree(a,b)
fun merge_subtrees(ord, left, right) {
  # TODO optimise and perform rebalacing
  fold_tree(fun (key, value, acc) {
    upd_tree(ord, key, value, acc)
  }, right, left)
}

sig del_tree : (Order(a, { |e}), a, Tree(a,b)) ~e~> Tree(a,b)
fun del_tree(ord, key, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(tree) ->
      switch (ord(key, tree.key)) {
        case Equal   -> merge_subtrees(ord, tree.left, tree.right)
        case Lower   -> Node(tree with left  = del_tree(ord, key, tree.left))
        case Greater -> Node(tree with right = del_tree(ord, key, tree.right))
      }
  }
}

sig del_map : (a, Map(a,b, { |e})) ~e~> Map(a,b, { |e})
fun del_map(key, mp) {
  var (ord=ord, tree=tree) = mp;
  (mp with tree = del_tree(ord, key, tree))
}

# End library

typename Complex = (Float, Float);

sig @+ : (Complex, Complex) {}-> Complex
op z @+ w {
  var re = z.1 +. w.1;
  var im = z.2 +. w.2;
  (1=re, 2=im)
}

typename Orientation3D = (phi:Float, theta:Float);
typename Probability = Float;
typename Spin = [| Up | Down |];

typename Qubit = [| Qubit:(Int) |];

# TODO: representation in separate qubits or whole state?
# I prefer whole state (so do many Ã›), but need to reconcile that with
# individual qubits in A/B pov

# Individual first - no entanglement; then together

typename Ket = [Complex];
typename Operator = [[Complex]];

typename State = (individual:Map(Qubit, Ket, {}), full:Ket);

sig init_state : () {}-> State
fun init_state() {
  fun qubit_ord(Qubit(l):Qubit, Qubit(r):Qubit) {
    def_ord(l, r)
  }
  var mp = make_map(qubit_ord);
  var ket = [];
  (individual=mp, full=ket)
}

sig global_state_manager : (State,
                            Comp(a, { New:Qubit
                                    # , Apply:(Operator, Qubit) {}-> ()
                                    , Measure:(Orientation3D, Qubit) {}-> Spin })) -> a
fun global_state_manager(gs, f) {
  shallowhandle(f()) {
    case Return(v) -> v
    case New(r) ->
      var qb = Qubit(gensym());
      var ket = [(1.0, 0.0), (0.0, 0.0)];
      var mp' = upd_map(qb, ket, gs.individual);
      var full' = gs.full ++ ket;
      var gs' = (individual=mp', full=full');
      global_state_manager(gs', r)
    # case Apply(operator, qb) ->
    #   var st =
    case Measure(orientation, qb, r) ->
      global_state_manager(gs, fun() { r(Up) })
  }
}
