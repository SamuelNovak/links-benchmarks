############################################################################################
# N-body simulation using Effects and Handlers: layered abstraction                        #
# =================================================================                        #
#                                                                                          #
# TODO fill this part (reference <simple.links>)                                           #
#                                                                                          #
############################################################################################

# Type aliases:
typename Triple(a) = (a, a, a);
typename Alist(a, b) = [(a, b)];

sig fst : ((a,b)) -> a
fun fst((x,_)) { x }

############ STATE ############

sig assoc : (a, Alist(a,b)) ~> Maybe(b)
fun assoc(k, alst) {
  switch (alst) {
    case [] -> Nothing
    case ((xk, xv)::rest) -> if (k == xk)
                               { Just(xv) }
                             else
                               { assoc(k, rest) }
  }
}

sig upd_assoc : (a, b, Alist(a,b)) ~> Alist(a,b)
fun upd_assoc(k, v, alst) {
  switch (alst) {
    case [] -> [(k,v)]
    case ((xk, xv)::rest) -> if (k == xk)
                               { (k, v) :: rest }
                             else
                               { (xk, xv) :: upd_assoc(k, v, rest) }
  }
}

sig assoc_keys : (Alist(a,b)) ~> [a]
fun assoc_keys(alst) {
  map(fst, alst)
}

# Handler stuff:

sig statemgr : (Alist(a,b), () { Ask:(a) {}-> Maybe(b)
                               , Put:(a, b) {}-> ()
                               , Dump:() {}-> Alist(a,b) |e}~> c)
               {Ask{_},Put{_},Dump{_}|e}~> c
fun statemgr(state, f) {
  shallowhandle (f()) {
    case Return(v) -> v

    case Ask(k, resume)    -> { var v = assoc(k, state);
                                statemgr(state, fun() { resume(v) }) }

    case Put(k, v, resume) -> { var state' = upd_assoc(k, v, state);
                                statemgr(state', fun() { resume(()) }) }

    case Dump(resume)      -> { statemgr(state, fun() { resume(state) })}
  }
}


sig ask : (a) {Ask:(a) {}-> b|e}~> b
fun ask(k) { do Ask(k) }

sig put : (a, b) {Put:(a, b) {}-> ()|e}~> ()
fun put(k, v) { do Put(k, v) }

# debug
sig dump : () {Dump:() {}-> Alist(a,b)|e}~> Alist(a,b)
fun dump() { do Dump }

fun local_state(f) { statemgr([], f) }


############ PHYSICS ############

# Vector helpers:

typename Vector3 = Triple(Float);
var zero3 = (0.0, 0.0, 0.0) : Vector3;
typename Scalar = Float;

infixl 5 +++;
op (ux,uy,uz) +++ (vx,vy,vz) { (ux +. vx, uy +. vy, uz +. vz ) }
infixl 5 ---;
op (ux,uy,uz) --- (vx,vy,vz) { (ux -. vx, uy -. vy, uz -. vz ) }

sig vector_sum : ([Vector3]) ~> Vector3
fun vector_sum(lst) {
  fold_left((+++), zero3, lst)
}

infix 5 **.;
op s **. (x,y,z) { (s *. x, s *. y, s *. z) }

sig norm2 : (Vector3) -> Float
fun norm2((x,y,z)) {
  x *. x +. y *. y +. z *. z
}

sig norm : (Vector3) -> Float
fun norm(v) {
  sqrt(norm2(v))
}

# Physical state: DSL

typename Property = [| Mass
                     | Pos
                     | Vel |];

typename Result = [| S':Scalar | V':Vector3 |];

prefix 6 @!;
sig @! : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Result
op @! p {
  var v = ask(p);
  switch (v) {
    case Nothing -> error("Undefined symbol")
    case Just(v) -> v
  }
}


prefix 6 @!$;
sig @!$ : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Scalar
op @!$ p {
  switch(@!p) {
    case S'(v) -> v
    case _ -> error("Invalid scalar projection.")
  }
}


prefix 6 @!>;
sig @!> : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Vector3
op @!> p {
  switch(@!p) {
    case V'(v) -> v
    case _ -> error("Invalid vector projection.")
  }
}


infix 4 @=;
sig @= : (Property, Result) {Put:(Property, Result) {}-> ()|e}~> ()
op p @= v {
  put(p, v)
}

infix 4 @=$;
sig @=$ : (Property, Scalar) ~%~> ()
op p @=$ s {
  p @= S'(s)
}

infix 4 @=<;
sig @=< : (Property, Vector3) ~%~> ()
op p @=< v {
  p @= V'(v)
}

infix 4 @=<+;
sig @=<+ : (Property, Vector3) {Ask:(Property) {}-> Maybe(Result),
                                Put:(Property, Result) {}-> ()|e}~> ()
op p @=<+ v {
  p @=< (@!> p) +++ v
}

infix 4 @=<-;
sig @=<- : (Property, Vector3) {Ask:(Property) {}-> Maybe(Result),
                                Put:(Property, Result) {}-> ()|e}~> ()
op p @=<- v {
  p @=< (@!> p) --- v
}


# Bodies:

typename Body = ( mass : Float
                , pos  : Vector3
                , vel  : Vector3 );

typename Energy = Scalar;

sig body : (Body) { Ask:(Property) {}-> Maybe(Result)
                  , Put:(Property, Result) {}-> ()
                  , Interact:(Scalar, Vector3, Energy) {}-> (Scalar, Vector3)
                  , Spawn:(Body) {}-> Vector3 |e}~> ()
fun body(bd) {
  # momentum correction obtained here
  var delta_p = do Spawn(bd);

  Mass @=$ bd.mass;
  Pos  @=< bd.pos;
  # (stellar) momentum correction; may not work well for multi-star systems
  Vel  @=< bd.vel +++ ((1.0 /. bd.mass) **. delta_p);

  fun advance() {
    # TODO so many accesses will be inefficient AF if I keep using
    # Alists, but eh, demonstration purposes (maybe just move the
    # entire body at all times, because this *slightly* optimised code
    # does it anyway)
    var mass = @!$ Mass;
    var pos  = @!> Pos;
    var vel  = @!> Vel;

    var ke = mass *. norm2(vel) /. 2.0;

    var (dt, delta_p) = do Interact(mass, pos, ke);
    var vel = @!> Vel +++ ((1.0 /. mass) **. delta_p);

    Vel @=< vel;
    Pos @=<+ dt **. vel;

    advance()
  }

  advance()
}

# The Physical Universe:

# sig handle_spawn : ([() {Spawn:(Body) {}-> Vector3|e}~> ()])
#                    {Spawn{-}|e}~>
#                    [(Body, (Vector3) {Spawn:(Body) {}-> Vector3|e}~> ())]
fun handle_spawn(rest) {
  switch (rest) {
    case [] -> []
    case b :: rest ->
      var (bd, resume) = shallowhandle(b()) {
        case Return() -> error("Incompatible body-function.")
        case Spawn(bd, resume) -> (bd, resume)
      };
      (bd, resume) :: handle_spawn(rest)
  }
}

# sig collect_interaction_requests : ([() {Interact:(Scalar, Vector3, Energy) -> (Scalar, Vector3)|e}~> ()])
#                                    ~e~>
#                                    (Energy, [(mass:Scalar, pos:Vector3)], [((Scalar, Vector3)) {Interact:(Scalar, Vector3, Energy) -> (Scalar, Vector3)|e}~> ()])
fun collect_interaction_requests(bodies) {
  switch (bodies) {
    case [] -> (0.0, [], [])
    case b :: rest ->
      var (mass:Scalar, pos:Vector3, ke:Energy, res) = shallowhandle(b()) {
        case Return() -> error("Incompatible body-function.")
        case Interact(mass, pos, ke, res) -> (mass, pos, ke, res)
      };
      var (e_total, pairs, rest) = collect_interaction_requests(rest);
      var e_total = e_total +. ke;
      var pairs = (mass=mass, pos=pos) :: pairs;
      (e_total, pairs, res :: rest)
  }
}

fun universe(n_iter, dt, bodies) {
  var bodies = handle_spawn(bodies);

  var (dp:Vector3
      ,initial_energy:Energy
      ,_) = fold_left(fun ((dp, initial_energy, acc), (body, _)) {
    var (mass=mass, vel=vel, pos=pos) = body;
    var dp = dp --- (mass **. vel);

    var ke = mass *. norm2(vel) /. 2.0;
    var pe = fold_left(fun (pe, other) {
      var dr = pos --- other.pos;
      var d = norm(dr);
      pe -. (mass *. other.mass /. d)
    }, 0.0, acc);

    var initial_energy = initial_energy +. ke +. pe;
    (dp, initial_energy, body :: acc)
  }, (zero3, 0.0, []), bodies);

  # find the most massive object - the star of the system
  # TODO maybe join this with the above
  var (sun, rest) = fold_left(fun ((max, acc), (body, resumption)) {
    switch (max) {
      case Nothing -> (Just((body, resumption)), acc)
      case Just((sun, sun_res)) -> {
        if (body.mass > sun.mass)
          { (Just((body, resumption)), (sun, sun_res) :: acc) }
        else
          { (max, (body, resumption) :: acc) }
      }
    }
  }, (Nothing, []), bodies);

  var sun = switch(sun) {
    case Nothing -> error("Empty universe")
    # correction dp will be applied to the sun
    case Just((_, resume)) -> fun () { resume(dp) }
  };

  var rest = map(fun((_, resume))() { resume(zero3) }, rest);

  var bodies = sun :: rest;

  var int_reqs = collect_interaction_requests(bodies);
  # var energy_start = energy();

  # handle interactions until n_iter

  # energy again

  (start=0.0:Scalar, end=0.0:Scalar)
}

# Initialization of the solar system

fun init_body(bd) {
  fun () {
    local_state(fun() { body(bd) })
  }
}


fun init_system() {
  var pi = 3.141592653589793;
  var solar_mass = 4.0 *. pi *. pi;
  var days_per_year = 365.24;

  var bodies = [
    # sun
    ( mass = solar_mass
    , pos  = zero3
    , vel  = zero3 ),

    # jupiter
    ( mass =     9.54791938424326609e-4 *. solar_mass
    , pos  = (   4.84143144246472090e0
             , -.1.16032004402742839e0
             , -.1.03622044471123109e-1 )
    , vel  = days_per_year **.
             (   1.66007664274403694e-3
             ,   7.69901118419740425e-3
             , -.6.90460016972063023e-5 )),

    # saturn
    ( mass =     2.85885980666130812e-4 *. solar_mass
    , pos  = (   8.34336671824457987e0
             ,   4.12479856412430479e0
             , -.4.03523417114321381e-1 )
    , vel  = days_per_year **.
             ( -.2.76742510726862411e-3
             ,   4.99852801234917238e-3
             ,   2.30417297573763929e-5 )),

    # uranus
    ( mass =     4.36624404335156298e-5 *. solar_mass
    , pos  = (   1.28943695621391310e1
             , -.1.51111514016986312e1
             , -.2.23307578892655734e-1 )
    , vel  = days_per_year **.
             (   2.96460137564761618e-3
             ,   2.37847173959480950e-3
             , -.2.96589568540237556e-5 )),

    # neptune
    ( mass =     5.15138902046611451e-5 *. solar_mass
    , pos  = (   1.53796971148509165e1
             , -.2.59193146099879641e1
             ,   1.79258772950371181e-1 )
    , vel  = days_per_year **.
             (   2.68067772490389322e-3
             ,   1.62824170038242295e-3
             , -.9.51592254519715870e-5 ))
  ];

  map(init_body, bodies)
}


############ PROGRAM ENTRY ############

# fun simulation(n, dt) {
#   init_system()
# }

# typename Setup = [| Correctness | Performance |];

# sig run_sim : (Setup) ~%~> ()
# fun run_sim(setup) {
#   var n = switch(setup) {
#     case Correctness -> 1000
#     case Performance -> 50000000
#   };
#   var dt = 0.01;
#   # TODO run simulation
#   ()
# }

# fun main() {
#   run_sim(Correctness)
# }


