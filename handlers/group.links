# Trees and Maps

typename Ord = [| Lower | Greater | Equal |];
typename Order(a, e::Eff) = (a, a) ~e~> Ord;

typename Tree(a, b) = mu t. [| Node:(left:t, key:a, value:b, right:t) | Leaf |];
typename Map(a, b, e::Eff) = (ord:Order(a, { |e}), tree:Tree(a,b));

# default ordering
sig ord : Order(a)
fun ord(x, y) { if (x == y) Equal else if (x < y) Lower else Greater }

# make_map : (Order (a,{ |e})) -> Map (a,b,{ |e})
# want the arrow to NOT share with Order and Map here
sig make_map : (Order(a)) -f-> Map(a, b)
fun make_map(ord) {
  (ord=ord, tree=Leaf)
}

# find_tree_opt : (Order (a,{ |e}), a, Tree (a,b)) ~e~> Maybe (b)
sig find_tree_opt : (Order(a), a, Tree(a,b)) ~> Maybe(b)
fun find_tree_opt(ord, key, tree) {
  switch (tree) {
    case Leaf -> Nothing
    case Node(tree) ->
      switch (ord(key, tree.key)) {
        case Equal   -> Just(tree.value)
        case Lower   -> find_tree_opt(ord, key, tree.left)
        case Greater -> find_tree_opt(ord, key, tree.right)
      }
  }
}

# ref_map : (a, Map(a,b,{ |e})) { |e}~> Maybe(b)
sig ref_map : (a, Map(a,b)) ~> Maybe(b)
fun ref_map(key, mp) {
  var (ord=ord, tree=tree) = mp;
  find_tree_opt(ord, key, tree)
}

# TODO rebalancing
sig upd_tree : (Order(a), a, b, Tree(a,b)) ~> Tree(a,b)
fun upd_tree(ord, key, value, tree) {
  var tree = switch (tree) {
               case Leaf -> (key=key, value=value, left=Leaf, right=Leaf)
               case Node(tree) ->
                 switch (ord(key, tree.key)) {
                   case Equal   -> (tree with value = value)
                   case Lower   -> (tree with left  = upd_tree(ord, key, value, tree.left))
                   case Greater -> (tree with right = upd_tree(ord, key, value, tree.right))
                 }
             };
  Node(tree)
}

# sig upd_map : (a, b, Map(a,b,{ |e})) ~e~> Map(a,b,{ |e})
sig upd_map : (a, b, Map(a,b)) ~> Map(a,b)
fun upd_map(key, value, mp) {
  var (ord=ord, tree=tree) = mp;
  (mp with tree = upd_tree(ord, key, value, tree))
}

sig map_tree : ((a) ~> b, Tree(k, a)) ~> Tree(k, b)
fun map_tree(f, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(tree) ->
      var left  = map_tree(f, tree.left);
      var value = f(tree.value);
      var right = map_tree(f, tree.right);
      Node(key=tree.key, value=value, left=left, right=right)
  }
}

# sig map_map : ((a) ~f~> b, Map(k, a, { |e})) ~f~> Map(k, b, { |e})
sig map_map : ((a) ~f~> b, Map(k, a)) ~f~> Map(k, b)
fun map_map(f, mp) {
  var (ord=ord, tree=tree) = mp;
  var tree = map_tree(f, tree);
  (ord=ord, tree=tree)
}

sig fold_tree : ((a, b, q) ~> q, Tree(a, b), q) ~> q
fun fold_tree(f, tree, acc) {
  switch (tree) {
    case Leaf -> acc
    case Node(tree) ->
      var acc = fold_tree(f, tree.left, acc);
      var acc = f(tree.key, tree.value, acc);
      var acc = fold_tree(f, tree.right, acc);
      acc
  }
}

# surprisingly here the desugaring works
sig fold_map : ((a, b, q) ~> q, Map(a, b), q) ~> q
fun fold_map(f, mp, acc) {
  var (ord=ord, tree=tree) = mp;
  fold_tree(f, tree, acc)
}

sig merge_subtrees : (Order(a), Tree(a,b), Tree(a,b)) ~> Tree(a,b)
fun merge_subtrees(ord, left, right) {
  # TODO optimise and perform rebalacing
  fold_tree(fun (key, value, acc) {
    upd_tree(ord, key, value, acc)
  }, right, left)
}

sig del_tree : (Order(a), a, Tree(a,b)) ~> Tree(a,b)
fun del_tree(ord, key, tree) {
  switch (tree) {
    case Leaf -> Leaf
    case Node(tree) ->
      switch (ord(key, tree.key)) {
        case Equal   -> merge_subtrees(ord, tree.left, tree.right)
        case Lower   -> Node(tree with left  = del_tree(ord, key, tree.left))
        case Greater -> Node(tree with right = del_tree(ord, key, tree.right))
      }
  }
}

# sig del_map : (a, Map(a,b, { |e})) ~e~> Map(a,b, { |e})
sig del_map : (a, Map(a,b)) ~> Map(a,b)
fun del_map(key, mp) {
  var (ord=ord, tree=tree) = mp;
  (mp with tree = del_tree(ord, key, tree))
}


# Set:

typename Set(a) = Map(a, ());

# want the arrow to not share
sig make_set : (Order(a)) -f-> Set(a)
fun make_set(ord) {
  make_map(ord)
}

# sig add_set : (a, Set(a, { |e})) ~e~> Set(a, { |e})
sig add_set : (a, Set(a)) ~> Set(a)
fun add_set(key, s) {
  upd_map(key, (), s)
}

# sig set_of_list : (Order(a, { |e}), [a]) ~e~> Set(a, { |e})
sig set_of_list : (Order(a), [a]) ~> Set(a)
fun set_of_list(ord, lst) {
  fold_left(fun (s, x) { add_set(x, s) }, make_set(ord), lst)
}

sig has_set : (a, Set(a)) ~> Bool
fun has_set(key, s) {
  switch (ref_map(key, s)) {
    case Just(()) -> true
    case Nothing  -> false
  }
}

# sig del_set : (a, Set(a, { |e})) ~e~> Set(a, { |e})
sig del_set : (a, Set(a)) ~> Set(a)
fun del_set(key, s) {
  del_map(key, s)
}

sig cart : (Set(a, { |e}), Set(b, { |e})) ~e~> Set((a,b), { |e})
# explicitly putting effects here, so that the same effect variable
# can be inside too, but maybe this is not necessary
# sig cart : (Set(a), Set(b)) ~> Set((a,b))
fun cart(left, right) {
  var (ord=ord_left|_) = left;
  var (ord=ord_right|_) = right;

  sig ord : Order((a,b), { |e})
  fun ord((xl, xr), (yl, yr)) {
    switch (ord_left(xl, yl)) {
      case Equal -> ord_right(xr, yr)
      case Lower -> Lower
      case Greater -> Greater
    }
  }

  fold_map(fun (key_left, (), acc_left) {
    fold_map(fun (key_right, (), acc_right) {
      add_set((key_left, key_right), acc_right)
    }, right, acc_left)
  }, left, make_set(ord))
}

# Group:

# TODO: the same effect for both?
# typename Group(a, e::Eff) = (carrier:Set(a, { |e}), mult:Map((a,a), a, { |e}));
typename Group(a) = (carrier:Set(a), mult:Map((a,a), a));

# sig set_group_mlt : ((a, a), a, Group(a, { |e})) ~e~> Group(a, { |e})
sig set_group_mlt : ((a, a), a, Group(a)) ~> Group(a)
fun set_group_mlt((left, right), res, grp) {
  var (carrier=carrier, mult=mult) = grp;
  if (has_set(left, carrier) && has_set(right, carrier)) {
    (grp with mult = upd_map((left, right), res, mult))
  } else {
    error("Attempting to add a group multiplication where one or both values do not belong to the group.")
  }
}

# Create a group where all multiplications go to the identity element (default case, this is to be modified later)
# sig make_group : (Set(a, { |e}), a) ~e~> Group(a, { |e})
sig make_group : (Set(a), a) ~> Group(a)
fun make_group(carrier, identity) {
  var carXcar = cart(carrier, carrier);
  var mult = map_map(fun (()) { identity }, carXcar);
  (carrier=carrier, mult=mult)
}
