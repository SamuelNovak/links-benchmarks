############################################################################################
# N-body simulation using Effects and Handlers: layered abstraction                        #
# =================================================================                        #
#                                                                                          #
# TODO fill this part (reference <simple.links>)                                           #
#                                                                                          #
############################################################################################

# Type aliases:
typename Triple(a) = (a, a, a);
typename Alist(a, b) = [(a, b)];

sig fst : ((a,b)) -> a
fun fst((x,_)) { x }

############ STATE ############

sig assoc : (a, Alist(a,b)) ~> Maybe(b)
fun assoc(k, alst) {
  switch (alst) {
    case [] -> Nothing
    case ((xk, xv)::rest) -> if (k == xk)
                               { Just(xv) }
                             else
                               { assoc(k, rest) }
  }
}

sig upd_assoc : (a, b, Alist(a,b)) ~> Alist(a,b)
fun upd_assoc(k, v, alst) {
  switch (alst) {
    case [] -> [(k,v)]
    case ((xk, xv)::rest) -> if (k == xk)
                               { (k, v) :: rest }
                             else
                               { (xk, xv) :: upd_assoc(k, v, rest) }
  }
}

sig assoc_keys : (Alist(a,b)) ~> [a]
fun assoc_keys(alst) {
  map(fst, alst)
}

# Handler stuff:

sig statemgr : (Alist(a,b), () { Ask:(a) {}-> Maybe(b)
                               , Put:(a, b) {}-> ()
                               , Dump:() {}-> Alist(a,b) |e}~> c)
               {Ask{_},Put{_},Dump{_}|e}~> c
fun statemgr(state, f) {
  shallowhandle (f()) {
    case Return(v) -> v

    case Ask(k, resume)    -> { var v = assoc(k, state);
                                statemgr(state, fun() { resume(v) }) }

    case Put(k, v, resume) -> { var state' = upd_assoc(k, v, state);
                                statemgr(state', fun() { resume(()) }) }

    case Dump(resume)      -> { statemgr(state, fun() { resume(state) })}
  }
}


sig ask : (a) {Ask:(a) {}-> b|e}~> b
fun ask(k) { do Ask(k) }

sig put : (a, b) {Put:(a, b) {}-> ()|e}~> ()
fun put(k, v) { do Put(k, v) }

# debug
sig dump : () {Dump:() {}-> Alist(a,b)|e}~> Alist(a,b)
fun dump() { do Dump }

fun local_state(f) { statemgr([], f) }


############ PHYSICS ############

# Vector helpers:

typename Vector3 = Triple(Float);
var zero3 = (0.0, 0.0, 0.0) : Vector3;
typename Scalar = Float;

infixl 5 +++;
op (ux,uy,uz) +++ (vx,vy,vz) { (ux +. vx, uy +. vy, uz +. vz ) }
infixl 5 ---;
op (ux,uy,uz) --- (vx,vy,vz) { (ux -. vx, uy -. vy, uz -. vz ) }

sig vector_sum : ([Vector3]) ~> Vector3
fun vector_sum(lst) {
  fold_left((+++), zero3, lst)
}

infix 5 **.;
op s **. (x,y,z) { (s *. x, s *. y, s *. z) }

sig norm2 : (Vector3) -> Float
fun norm2((x,y,z)) {
  x *. x +. y *. y +. z *. z
}

sig norm : (Vector3) -> Float
fun norm(v) {
  sqrt(norm2(v))
}

# Physical state: DSL

typename Property = [| Mass
                     | Pos
                     | Vel |];

typename Result = [| S':Scalar | V':Vector3 |];

prefix 6 @!;
sig @! : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Result
op @! p {
  var v = ask(p);
  switch (v) {
    case Nothing -> error("Undefined symbol")
    case Just(v) -> v
  }
}


prefix 6 @!$;
sig @!$ : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Scalar
op @!$ p {
  switch(@!p) {
    case S'(v) -> v
    case _ -> error("Invalid scalar projection.")
  }
}


prefix 6 @!>;
sig @!> : (Property) {Ask:(Property) {}-> Maybe(Result)|e}~> Vector3
op @!> p {
  switch(@!p) {
    case V'(v) -> v
    case _ -> error("Invalid vector projection.")
  }
}


infix 4 @=;
sig @= : (Property, Result) {Put:(Property, Result) {}-> ()|e}~> ()
op p @= v {
  put(p, v)
}

infix 4 @=$;
sig @=$ : (Property, Scalar) ~%~> ()
op p @=$ s {
  p @= S'(s)
}

infix 4 @=<;
sig @=< : (Property, Vector3) ~%~> ()
op p @=< v {
  p @= V'(v)
}

infix 4 @=<+;
sig @=<+ : (Property, Vector3) {Ask:(Property) {}-> Maybe(Result),
                                Put:(Property, Result) {}-> ()|e}~> ()
op p @=<+ v {
  p @=< (@!> p) +++ v
}

infix 4 @=<-;
sig @=<- : (Property, Vector3) {Ask:(Property) {}-> Maybe(Result),
                                Put:(Property, Result) {}-> ()|e}~> ()
op p @=<- v {
  p @=< (@!> p) --- v
}


# Bodies:

typename Body = ( mass : Float
                , pos  : Vector3
                , vel  : Vector3 );

sig body : (Body) { Ask:(Property) {}-> Maybe(Result)
                  , Put:(Property, Result) {}-> ()
                  , Interact:(Scalar, Vector3, Scalar) {}-> (Scalar, Vector3)
                  , Spawn:(Body) {}-> Vector3 |e}~> ()
fun body(bd) {
  # momentum correction obtained here
  var delta_p = do Spawn(bd);

  Mass @=$ bd.mass;
  Pos  @=< bd.pos;
  # (stellar) momentum correction; may not work well for multi-star systems
  Vel  @=< bd.vel +++ ((1.0 /. bd.mass) **. delta_p);

  fun energy(mass, vel) {
    0.5 *. mass *. norm2(vel)
  }

  fun advance() {
    # TODO so many accesses will be inefficient AF if I keep using
    # Alists, but eh, demonstration purposes
    var mass = @!$ Mass;
    var pos  = @!> Pos;
    var vel  = @!> Vel;

    var (dt, delta_v) = do Interact(mass, pos, energy(mass, vel));
    var vel = @!> Vel +++ delta_v;

    Vel @=< vel;
    Pos @=<+ dt **. vel;

    advance()
  }

  advance()
}

# The Physical Universe:

sig handle_spawn : ([() {Spawn:(Body) {}-> Vector3|e}~> ()])
                   {Spawn{-}|e}~>
                   [(Body, (Vector3) {Spawn:(Body) {}-> Vector3|e}~> ())]
fun handle_spawn(rest) {
  switch (rest) {
    case [] -> []
    case b::rest ->
      var (bd, resume) = shallowhandle(b()) {
        case Return() -> error("Incompatible body-function.")
        case Spawn(bd, resume) -> (bd, resume)
      };
      (bd, resume) :: handle_spawn(rest)
  }
}

fun universe(n_iter, dt, bodies) {
  # TODO maybe the local state will happen before universe is given the bodies
  var bodies = map(fun (f)() { local_state(f) }, bodies);
  var bodies = handle_spawn(bodies);

  var dp = fold_left(fun (acc, ((mass=mass, vel=vel|_), _)) {
    acc --- (mass **. vel)
  }, zero3, bodies);

  # find the most massive object - the star of the system
  var (sun, rest) = fold_left(fun ((max, acc), (body, resumption)) {
    switch (max) {
      case Nothing -> (Just((body, resumption)), acc)
      case Just((sun, sun_res)) -> {
        if (body.mass > sun.mass)
          { (Just((body, resumption)), (sun, sun_res) :: acc) }
        else
          { (max, (body, resumption) :: acc) }
      }
    }
  }, (Nothing, []), bodies);

  # correction will be applied to the sun
  var sun = switch(sun) {
    case Nothing -> error("Empty universe")
    case Just((_, resume)) -> fun () { resume(dp) }
  };

  var rest = map(fun((_, resume))() { resume(zero3) }, rest);

  var bodies = sun :: rest;

  ()
}

# Initialization of the solar system

# sig offset_sun_momentum : (Scalar) {Ask:(Name) {}-> Maybe(Body),
#                                     Keys:() {}-> [Name],
#                                     Put:(Name, Body) {}-> ()|_}~> ()
# fun offset_sun_momentum(solar_mass) {
#   var bodies = keys();
#   var dp = fold_left(fun(acc, n) {
#     acc +++ (@!$ n @. Mass **. @!> n @. Vel)
#   }, zero3, bodies);
#   var v = (-. 1.0 /. solar_mass) **. dp;
#   Sun @. Vel @=< v
# }

# sig init_system : () {Ask:(Name) {}-> Maybe(Body),
#                       Keys:() {}-> [Name],
#                       Put:(Name, Body) {}-> ()|_}~> ()
# fun init_system() {
#   var pi = 3.141592653589793;
#   var solar_mass = 4.0 *. pi *. pi;
#   var days_per_year = 365.24;

#   Sun @=| ( mass = solar_mass
#           , pos = zero3
#           , vel = zero3 );

#   Jupiter @=| ( mass =     9.54791938424326609e-4 *. solar_mass
#               , pos  = (   4.84143144246472090e0
#                        , -.1.16032004402742839e0
#                        , -.1.03622044471123109e-1 )
#               , vel  = days_per_year **.
#                        (   1.66007664274403694e-3
#                        ,   7.69901118419740425e-3
#                        , -.6.90460016972063023e-5 ));

#   Saturn @=| ( mass =     2.85885980666130812e-4 *. solar_mass
#              , pos  = (   8.34336671824457987e0
#                       ,   4.12479856412430479e0
#                       , -.4.03523417114321381e-1 )
#              , vel  = days_per_year **.
#                       ( -.2.76742510726862411e-3
#                       ,   4.99852801234917238e-3
#                       ,   2.30417297573763929e-5 ));

#   Uranus @=| ( mass =     4.36624404335156298e-5 *. solar_mass
#              , pos  = (   1.28943695621391310e1
#                       , -.1.51111514016986312e1
#                       , -.2.23307578892655734e-1 )
#              , vel  = days_per_year **.
#                       (   2.96460137564761618e-3
#                       ,   2.37847173959480950e-3
#                       , -.2.96589568540237556e-5 ));

#   Neptune @=| ( mass =     5.15138902046611451e-5 *. solar_mass
#               , pos  = (   1.53796971148509165e1
#                        , -.2.59193146099879641e1
#                        ,   1.79258772950371181e-1 )
#               , vel  = days_per_year **.
#                        (   2.68067772490389322e-3
#                        ,   1.62824170038242295e-3
#                        , -.9.51592254519715870e-5 ));

#   offset_sun_momentum(solar_mass)
# }


############ PROGRAM ENTRY ############

# fun simulation(n, dt) {
#   init_system()
# }

# typename Setup = [| Correctness | Performance |];

# sig run_sim : (Setup) ~%~> ()
# fun run_sim(setup) {
#   var n = switch(setup) {
#     case Correctness -> 1000
#     case Performance -> 50000000
#   };
#   var dt = 0.01;
#   # TODO run simulation
#   ()
# }

# fun main() {
#   run_sim(Correctness)
# }


