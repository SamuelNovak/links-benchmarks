############################################################################################
# N-body simulation using Effects and Handlers (The Hopefully Fast Version TM) :D          #
# ============================================                                             #
#                                                                                          #
# Based on:										   #
# * the simple implementation in <nbody-simple.links>					   #
# * Mark C. Lewis's (with modifications from Chad Whipkey) "n-body Java #2 program"        #
#  <https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/nbody-java-2.html> #
# * and Troestler Christophe's implementation of the same problem in OCaml                 #
#  <https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/nbody-ocaml-1.html>#
#                                                                                          #
# Uses: TODO fill this                                                                     #
#                                                                                          #
############################################################################################

# Type aliases:
typename Triple(a) = (a, a, a);
typename Alist(a, b) = [(a, b)];

typename Vector3 = Triple(Float);
var zero3 = (0.0, 0.0, 0.0) : Vector3;
typename Scalar = Float;

typename Name = [| Sun
	         | Jupiter
		 | Saturn
		 | Uranus
		 | Neptune |];

typename Body = ( pos  : Vector3
                , vel  : Vector3
                , mass : Scalar );

typename State = ( sun     : Body
 	         , jupiter : Body
		 , saturn  : Body
		 , uranus  : Body
		 , neptune : Body );


# Helper functions:

sig fst : ((a,b)) -> a
fun fst((a,_)) { a }

sig snd : ((a,b)) -> b
fun snd((_,b)) { b }

## Vectors:
op (ux,uy,uz) +++ (vx,vy,vz) { (ux +. vx, uy +. vy, uz +. vz ) }
op (ux,uy,uz) --- (vx,vy,vz) { (ux -. vx, uy -. vy, uz -. vz ) }

sig vector_sum : ([Vector3]) ~> Vector3
fun vector_sum(lst) {
  fold_left((+++), zero3, lst)
}

op s **. (x,y,z) { (s *. x, s *. y, s *. z) }

sig norm2 : (Vector3) -> Float
fun norm2((x,y,z)) {
  x *. x +. y *. y +. z *. z
}

sig norm : (Vector3) -> Float
fun norm(v) {
  sqrt(norm2(v))
}

# Handler stuff:

# TODO SUGAR: here to omit the presence on the last arrow
sig env : (State, () {Ask:(Name) {}-> Body|e}~> d::Any) {Ask{_}|e}~> d
fun env(state, f) {
  handle (f()) {
    case Return(v) -> v
    case Ask(k, resume) -> {
      switch(k) {
        case Sun     -> resume(state.sun)
        case Jupiter -> resume(state.jupiter)
        case Saturn  -> resume(state.saturn)
        case Uranus  -> resume(state.uranus)
        case Neptune -> resume(state.neptune)
      }
    }
  }
}

sig statemgr : (State, () {Ask:(Name) {}-> Body, Put:(Name, Body) {}-> ()|e}~> b) {Ask{_},Put{_}|e}~> b
fun statemgr(state, f) {
  env(state, fun() {
    handle(f()) {
      case Return(x) -> x
      case Put(k, v, resume) -> {
        var state' = switch(k) {
	  case Sun     -> (state with sun = v)
          case Jupiter -> (state with jupiter = v)
          case Saturn  -> (state with saturn = v)
          case Uranus  -> (state with uranus = v)
          case Neptune -> (state with neptune = v)
	};
	env(state', fun() { resume(()) })
      }
    }
  })
}

sig ask : (a) {Ask:(a) {}-> b}-> b
fun ask(k) { do Ask(k) }

sig put : (a, b) {Put:(a, b) {}-> ()}-> ()
fun put(k, v) { do Put(k, v) }

