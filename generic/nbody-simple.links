############################################################################################
# N-body simulation                                                                        #
# =================                                                                        #
#                                                                                          #
# Based on Mark C. Lewis's (with modifications from Chad Whipkey) "n-body Java #2 program" #
#  <https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/nbody-java-2.html> #
#                                                                                          #
# Uses: TODO fill this                                                                     #
#                                                                                          #
############################################################################################

# Type aliases:
typename Triple(a) = (a, a, a);
# typename AList(a, b) = [(a, b)];

typename Vector3 = Triple(Float);
var zero3 = (0.0, 0.0, 0.0) : Vector3;
typename Scalar = Float;

typename Body = ( pos  : Vector3
                , vel  : Vector3
                , mass : Scalar );

# typename Name = [| Sun
#                  | Mercury
#                  | Venus
#                  | Earth
#                  | Mars
#                  | Jupiter
#                  | Saturn
#                  | Uranus
#                  | Neptune |];

# typename State = AList(Name, Body);
typename State = [Body];

# Helper functions:

sig fst : ((a,b)) -> a
fun fst((a,_)) { a }

sig snd : ((a,b)) -> b
fun snd((_,b)) { b }

sig map2 : ((a,b) ~> c, [a], [b]) ~> [c]
fun map2(f, xs, ys) {
  switch ((xs, ys)) {
    case ([], []) -> []
    case (x::xs, y::ys) -> f(x,y) :: map2(f, xs, ys)
    case _ -> error("Incompatible lists, map2 requires they have the same length.")
  }
}

# sig fst3 : (Triple(a)) -> a
# fun fst3((x,_,_)) { x }

# sig snd3 : (Triple(a)) -> a
# fun snd3((_,y,_)) { y }

# sig thd3 : (Triple(a)) -> a
# fun thd3((_,_,z)) { z }

op (ux,uy,uz) +++ (vx,vy,vz) { (ux +. vx, uy +. vy, uz +. vz ) }

# sig (---) : (Vector3, Vector3) -> Vector3
op (ux,uy,uz) --- (vx,vy,vz) { (ux -. vx, uy -. vy, uz -. vz ) }

sig vector_sum : ([Vector3]) ~> Vector3
fun vector_sum(lst) {
  fold_left((+++), zero3, lst)
}

# sig (**.) : (Float, Vector3) -> Vector3
op s **. (x,y,z) { (s *. x, s *. y, s *. z) }

# sig (--) : (Vector3) -> Vector3
# op -- u { (-.1.0) **. u  }

sig norm : (Vector3) -> Float
fun norm((x,y,z)) {
  var n2 = x *. x +. y *. y +. z *. z;
  sqrt(n2)
}


# sig assoc : (AList(a, b), a) ~> Maybe(b)
# fun assoc(alst, k) {
#   switch (alst) {
#     case []              -> Nothing
#     case ((xk,xv)::rest) -> if (xk == k)
#                             { Just(xv) }
#                           else
#                             { assoc(rest, k) }
#   }
# }

# sig upd_assoc : (AList(a,b), a, b) ~> AList(a,b)
# fun upd_assoc(alst, k, v) {
#   switch (alst) {
#     case []              -> [(k, v)]
#     case ((xk,xv)::rest) -> if (xk == k)
#                            { (k,v) :: rest }
#                          else
#                            { (xk,xv) :: upd_assoc(rest, k, v) }
#   }
# }

sig interact : (Float, Body, Body) -> (Body, Body)
fun interact(dt, (pos=r1, vel=v1, mass=m1),
                 (pos=r2, vel=v2, mass=m2)) {
  var dr = r1 --- r2;
  var d  = norm(dr);
  var mag = dt /. (d *. d *. d);

  var fc1 = m2 *. mag;
  var fc2 = m1 *. mag;

  var v1 = v1 --- (fc1 **. dr);
  var v2 = v2 +++ (fc2 **. dr);

  var b1 = (pos=r1, vel=v1, mass=m1);
  var b2 = (pos=r2, vel=v2, mass=m2);
  (b1, b2)
}


sig inter_fold : (Float) -> ((Body, [Body]), Body) -> (Body, [Body])
fun inter_fold(dt)((this:Body, acc:[Body]), other:Body) {
  var (this', other') = interact(dt, this, other);
  (this', other' :: acc)
}

sig advance : (Float) -> (State) ~> State
fun advance(dt)(system) {
  switch (system) {
    case [] -> []

    case body :: rest -> {

      var (body, rest) = fold_left(inter_fold(dt), (body, []), rest);

      var pos = body.pos +++ (dt **. body.vel);
      var body = (pos=pos, vel=body.vel, mass=body.mass);

      var rest = advance(dt)(rest);
      body :: rest
    }
  }
}
